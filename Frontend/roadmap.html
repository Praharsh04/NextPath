<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roadmap</title>
    <style>
        :root {
            --background: #F3F4F6;
            --text-primary: #1F2937;
            --text-secondary: #4B5563;
            --border-dark: #1F2937;
            --yellow-primary: #FDFF00;
            --yellow-hover: #D6D700;
            --cream-primary: #FFE599;
            --cream-hover: #F3C950;
            --blue-primary: #4136D4;
            --connector-color: #2B78E4;
            --shadow-color: rgba(0,0,0,0.1);
        }
        body {
            margin: 0;
            padding: 20px;
            background: var(--background);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #roadmap-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 40px;
            box-shadow: 0 4px 6px var(--shadow-color);
            overflow: hidden; /* Ensure shadows are not cut off */
        }

        /* Hover States */
        .topic-node:hover rect { fill: var(--yellow-hover); }
        .subtopic-node:hover rect { fill: var(--cream-hover); }

        /* Animation Keyframes */
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .node-animated {
          opacity: 0; /* Initial state for animation */
          animation: fadeInUp 0.4s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="roadmap-container"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const roadmapContainer = document.getElementById('roadmap-container');

            const roadmapDataString = sessionStorage.getItem('roadmapData');
            if (!roadmapDataString) {
                alert('Error: Roadmap data not found in session storage. Please generate a roadmap first.');
                window.location.href = 'index.html'; // Redirect back to initial page
                return;
            }

            let roadmapData;
            try {
                roadmapData = JSON.parse(roadmapDataString);
            } catch (e) {
                roadmapContainer.innerHTML = '<p>Error: Malformed roadmap JSON data in session storage.</p>';
                console.error('Malformed roadmap JSON:', e);
                return;
            }

            // Helper to create SVG elements
            function createSVGElement(tag, attributes = {}) {
                const element = document.createElementNS("http://www.w3.org/2000/svg", tag);
                for (const key in attributes) {
                    element.setAttribute(key, attributes[key]);
                }
                return element;
            }

            // Text wrapping/truncation helper
            function wrapText(text, maxWidthChars) {
                if (text.length <= maxWidthChars) return text;
                return text.substring(0, maxWidthChars - 3) + '...';
            }

            // --- Constants for Layout and Styling (from prompt) ---
            const VIEWBOX_WIDTH = 1845; // 1105 - (-740)
            const VIEWBOX_MIN_X = -740;
            const VIEWBOX_MIN_Y = -294;
            const CENTER_X = -191; // Approximate center X from roadmap.sh example

            // Spacing Constants
            const TITLE_TO_TOPIC = 162;
            const TOPIC_TO_SUBTOPIC_INITIAL = 200; 
            const SUBTOPIC_ROW_SPACING = 54; 
            const SUBTOPIC_TO_NEXT_TOPIC = 180; 
            const LEFT_SUBTOPIC_X_START = CENTER_X - 450; 
            const RIGHT_SUBTOPIC_X_START = CENTER_X + 42; 

            // Node Dimensions
            const TOPIC_NODE_WIDTH = 229.3;
            const TOPIC_NODE_HEIGHT = 46.3;
            const SUBTOPIC_NODE_MIN_WIDTH = 97;
            const SUBTOPIC_NODE_MAX_WIDTH = 277;
            const SUBTOPIC_NODE_HEIGHT = 46.3;
            const BUTTON_NODE_WIDTH = 200; 
            const BUTTON_NODE_HEIGHT = 46.3;
            const SECTION_NODE_WIDTH = 600; 
            const PARAGRAPH_NODE_WIDTH = 400; 

            // --- Dynamic Height Calculation ---
            function calculateRoadmapHeight(nodes) {
                let maxY = VIEWBOX_MIN_Y; // Start with viewBox minY
                nodes.forEach(node => {
                    if (node.y !== undefined) {
                        let nodeBottom = node.y;
                        let nodeHeight = node.height || 0;
                        if (node.type === 'title') {
                            nodeHeight = 28; // Approximate height for title text
                        } else if (node.type === 'topic') {
                            nodeHeight = TOPIC_NODE_HEIGHT;
                        } else if (node.type === 'subtopic') {
                            nodeHeight = SUBTOPIC_NODE_HEIGHT;
                        } else if (node.type === 'button') {
                            nodeHeight = BUTTON_NODE_HEIGHT;
                        }
                        nodeBottom = node.y + nodeHeight;
                        maxY = Math.max(maxY, nodeBottom);
                    }
                });
                return maxY + 200; // Add some bottom padding
            }

            const calculatedHeight = calculateRoadmapHeight(roadmapData.nodes);

            const svg = createSVGElement("svg", {
                width: "100%", // Make it responsive within its container
                height: calculatedHeight - VIEWBOX_MIN_Y,
                viewBox: `${VIEWBOX_MIN_X} ${VIEWBOX_MIN_Y} ${VIEWBOX_WIDTH} ${calculatedHeight - VIEWBOX_MIN_Y}`,
                style: `background-color: var(--background);`
            });

            // --- Define SVG Filters and Gradients ---
            const defs = createSVGElement("defs");

            // Box shadow for topics, subtopics, buttons, sections, paragraphs
            const boxShadowFilter = createSVGElement("filter", { id: "box-shadow" });
            boxShadowFilter.innerHTML = `
                <feGaussianBlur in="SourceAlpha" stdDeviation="3"/>
                <feOffset dx="0" dy="4" result="offsetblur"/>
                <feFlood flood-color="var(--shadow-color)"/>
                <feComposite in2="offsetblur" operator="in"/>
                <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            `;
            defs.appendChild(boxShadowFilter);
            
            // Text shadow for title
            const textShadowFilter = createSVGElement("filter", { id: "text-shadow" });
            textShadowFilter.innerHTML = `
                <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
                <feOffset dx="0" dy="1" result="offsetblur"/>
                <feFlood flood-color="rgba(0,0,0,0.15)"/>
                <feComposite in2="offsetblur" operator="in"/>
                <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            `;
            defs.appendChild(textShadowFilter);

            // Glow for connectors
            const connectorGlowFilter = createSVGElement("filter", { id: "connector-glow" });
            connectorGlowFilter.innerHTML = `
                <feGaussianBlur stdDeviation="2"/>
                <feFlood flood-color="rgba(43,120,228,0.3)"/>
                <feComposite operator="in"/>
                <feMerge>
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            `;
            defs.appendChild(connectorGlowFilter);

            svg.appendChild(defs);

            // Store node positions and dimensions for connections
            const nodeData = {};

            // --- Render Nodes ---
            roadmapData.nodes.forEach((node, index) => {
                let element;
                let textElement;
                let currentX = node.x;
                let currentY = node.y;
                let nodeWidth = node.width || 0;
                let nodeHeight = node.height || 0;

                switch (node.type) {
                    case "title":
                        element = createSVGElement("text", {
                            x: CENTER_X,
                            y: currentY,
                            "font-size": "28px",
                            "font-weight": "700",
                            "text-anchor": "middle",
                            fill: "var(--text-primary)",
                            filter: "url(#text-shadow)",
                            class: "node-animated"
                        });
                        element.textContent = node.title;
                        nodeWidth = element.getBBox ? element.getBBox().width : 0; // Estimate width for text
                        nodeHeight = 28; // Fixed height for title
                        break;
                    case "topic":
                        nodeWidth = TOPIC_NODE_WIDTH;
                        nodeHeight = TOPIC_NODE_HEIGHT;
                        currentX = CENTER_X - nodeWidth / 2; // Center topic nodes
                        element = createSVGElement("rect", {
                            x: currentX,
                            y: currentY,
                            width: nodeWidth,
                            height: nodeHeight,
                            fill: "var(--yellow-primary)",
                            stroke: "var(--border-dark)",
                            "stroke-width": 2.7,
                            rx: 5,
                            filter: "url(#box-shadow)",
                            class: "topic-node node-animated"
                        });
                        textElement = createSVGElement("text", {
                            x: CENTER_X,
                            y: currentY + nodeHeight / 2,
                            "font-size": "17px",
                            "font-weight": "normal",
                            "text-anchor": "middle",
                            "dominant-baseline": "middle",
                            fill: "var(--text-primary)",
                            class: "node-animated"
                        });
                        textElement.textContent = wrapText(node.title, 25);
                        break;
                    case "subtopic":
                        nodeWidth = node.width || SUBTOPIC_NODE_MAX_WIDTH; // Use node's width or default max
                        nodeHeight = SUBTOPIC_NODE_HEIGHT;
                        // Subtopics are positioned relative to their parent topic, this X is a placeholder
                        // Actual X will be calculated based on side and parent topic
                        currentX = node.side === "left" ? (CENTER_X + LEFT_SUBTOPIC_X_START) : (CENTER_X + RIGHT_SUBTOPIC_X_START);
                        element = createSVGElement("rect", {
                            x: currentX,
                            y: currentY,
                            width: nodeWidth,
                            height: nodeHeight,
                            fill: "var(--cream-primary)",
                            stroke: "var(--border-dark)",
                            "stroke-width": 2.7,
                            rx: 5,
                            filter: "url(#box-shadow)",
                            class: "subtopic-node node-animated"
                        });
                        textElement = createSVGElement("text", {
                            x: currentX + nodeWidth / 2,
                            y: currentY + nodeHeight / 2,
                            "font-size": "17px",
                            "font-weight": "normal",
                            "text-anchor": "middle",
                            "dominant-baseline": "middle",
                            fill: "var(--text-primary)",
                            class: "node-animated"
                        });
                        textElement.textContent = wrapText(node.title, 25);

                        // Add badge if specified
                        if (node.badge) {
                            const badgeColor = {
                                "recommended": "#874EFE",
                                "alternative": "#4F7A28",
                                "optional": "#929292"
                            }[node.badge];

                            const badgeCircle = createSVGElement("circle", {
                                cx: currentX + 9.5, // Position top-left, overlapping by 10px
                                cy: currentY + 9.5,
                                r: 9.5,
                                fill: badgeColor,
                                class: "node-animated"
                            });
                            svg.appendChild(badgeCircle);

                            // Add checkmark for recommended badge
                            if (node.badge === "recommended") {
                                const checkmark = createSVGElement("path", {
                                    d: `M ${currentX + 9.5 - 4},${currentY + 9.5} L ${currentX + 9.5 - 1.5},${currentY + 9.5 + 3} L ${currentX + 9.5 + 3.5},${currentY + 9.5 - 2}`,
                                    fill: "none",
                                    stroke: "white",
                                    "stroke-width": 2,
                                    "stroke-linecap": "round",
                                    class: "node-animated"
                                });
                                svg.appendChild(checkmark);
                            }
                        }
                        break;
                    case "button":
                        nodeWidth = node.width || BUTTON_NODE_WIDTH;
                        nodeHeight = BUTTON_NODE_HEIGHT;
                        currentX = CENTER_X - nodeWidth / 2;
                        element = createSVGElement("rect", {
                            x: currentX,
                            y: currentY,
                            width: nodeWidth,
                            height: nodeHeight,
                            fill: "var(--blue-primary)",
                            stroke: "var(--blue-primary)",
                            "stroke-width": 2.7,
                            rx: 5,
                            filter: "url(#box-shadow)",
                            class: "button-node node-animated"
                        });
                        textElement = createSVGElement("text", {
                            x: CENTER_X,
                            y: currentY + nodeHeight / 2,
                            "font-size": "17px",
                            "font-weight": "normal",
                            "text-anchor": "middle",
                            "dominant-baseline": "middle",
                            fill: "white",
                            class: "node-animated"
                        });
                        textElement.textContent = node.title;
                        if (node.url) {
                            element.addEventListener('click', () => window.open(node.url, '_blank'));
                            element.style.cursor = 'pointer';
                            textElement.addEventListener('click', () => window.open(node.url, '_blank'));
                            textElement.style.cursor = 'pointer';
                        }
                        break;
                    case "vertical": // Vertical line node (main spine)
                        element = createSVGElement("line", {
                            x1: node.x1,
                            y1: node.y1,
                            x2: node.x2,
                            y2: node.y2,
                            stroke: "var(--connector-color)",
                            "stroke-width": 3.75,
                            "stroke-dasharray": node.style === "dashed" ? "0.8 8" : "0",
                            "stroke-linecap": "round",
                            filter: "url(#connector-glow)",
                            class: "node-animated"
                        });
                        break;
                    case "horizontal": // Horizontal line node
                        element = createSVGElement("line", {
                            x1: node.x1,
                            y1: node.y1,
                            x2: node.x2,
                            y2: node.y2,
                            stroke: "var(--connector-color)",
                            "stroke-width": 3.75,
                            "stroke-dasharray": node.style === "dashed" ? "0.8 8" : "0",
                            "stroke-linecap": "round",
                            filter: "url(#connector-glow)",
                            class: "node-animated"
                        });
                        break;
                    case "section":
                        nodeWidth = node.width || SECTION_NODE_WIDTH;
                        nodeHeight = node.height || 100; // Default height for section
                        currentX = node.x || (CENTER_X - SECTION_NODE_WIDTH / 2);
                        element = createSVGElement("rect", {
                            x: currentX,
                            y: currentY,
                            width: nodeWidth,
                            height: nodeHeight,
                            fill: "white",
                            stroke: "var(--border-dark)",
                            "stroke-width": 2.7,
                            rx: 5,
                            filter: "url(#box-shadow)",
                            class: "section-node node-animated"
                        });
                        textElement = createSVGElement("text", {
                            x: CENTER_X,
                            y: currentY + 20,
                            "font-size": "20px",
                            "font-weight": "bold",
                            "text-anchor": "middle",
                            fill: "var(--text-primary)",
                            class: "node-animated"
                        });
                        textElement.textContent = node.title;
                        break;
                    case "paragraph":
                        nodeWidth = node.width || PARAGRAPH_NODE_WIDTH;
                        nodeHeight = node.height || 100; // Default height for paragraph
                        currentX = node.x || (CENTER_X - PARAGRAPH_NODE_WIDTH / 2);
                        element = createSVGElement("rect", {
                            x: currentX,
                            y: currentY,
                            width: nodeWidth,
                            height: nodeHeight,
                            fill: "white",
                            stroke: "var(--border-dark)",
                            "stroke-width": 2.5,
                            rx: 5,
                            filter: "url(#box-shadow)",
                            class: "paragraph-node node-animated"
                        });
                        textElement = createSVGElement("text", {
                            x: CENTER_X,
                            y: currentY + 20,
                            "font-size": "16px",
                            "text-anchor": "middle",
                            fill: "var(--text-primary)",
                            class: "node-animated"
                        });
                        textElement.textContent = wrapText(node.title, 50); // Example truncation
                        break;
                    default:
                        console.warn("Unknown node type:", node.type);
                        return;
                }

                if (element) {
                    svg.appendChild(element);
                    nodeData[node.id] = { x: currentX, y: currentY, width: nodeWidth, height: nodeHeight, type: node.type };
                }
                if (textElement) {
                    svg.appendChild(textElement);
                }
            });

            // Render connections
            roadmapData.connections.forEach(connection => {
                const fromNode = nodeData[connection.from];
                const toNode = nodeData[connection.to];

                if (!fromNode || !toNode) {
                    console.warn("Missing node for connection:", connection);
                    return;
                }

                let pathD;
                let startX, startY, endX, endY;

                if (connection.type === "vertical") {
                    startX = fromNode.x + fromNode.width / 2;
                    startY = fromNode.y + fromNode.height;
                    endX = toNode.x + toNode.width / 2;
                    endY = toNode.y;
                    pathD = `M ${startX},${startY} L ${endX},${endY}`;
                } else if (connection.type === "curved") {
                    startY = fromNode.y + fromNode.height / 2;
                    endY = toNode.y + toNode.height / 2;

                    // Adjust startX and endX based on which side the subtopic is
                    if (fromNode.type === "subtopic") {
                        if (fromNode.x < toNode.x) { // Subtopic on left, connecting to right of topic
                            startX = fromNode.x + fromNode.width;
                            endX = toNode.x;
                        } else { // Subtopic on right, connecting to left of topic
                            startX = fromNode.x;
                            endX = toNode.x + toNode.width;
                        }
                    }
                     else { // General curved connection between other nodes
                        startX = fromNode.x + fromNode.width / 2;
                        endX = toNode.x + toNode.width / 2;
                    }

                    const controlPointOffset = Math.abs(endX - startX) * 0.35;

                    if (startX < endX) { // Connecting from left to right
                        pathD = `M ${startX},${startY} C ${startX + controlPointOffset},${startY} ${endX - controlPointOffset},${endY} ${endX},${endY}`;
                    } else { // Connecting from right to left
                        pathD = `M ${startX},${startY} C ${startX - controlPointOffset},${startY} ${endX + controlPointOffset},${endY} ${endX},${endY}`;
                    }
                }

                if (pathD) {
                    const connectorPath = createSVGElement("path", {
                        d: pathD,
                        stroke: "var(--connector-color)",
                        "stroke-width": 3.5,
                        "stroke-dasharray": connection.style === "dashed" ? "0.8 8" : "0",
                        fill: "none",
                        "stroke-linecap": "round",
                        "stroke-linejoin": "round",
                        "stroke-opacity": 1,
                        filter: "url(#connector-glow)",
                        class: "node-animated"
                    });
                    svg.appendChild(connectorPath);
                }
            });

            // Render Legend
            const legendX = -713;
            const legendY = -272;
            const legendWidth = 351;
            const legendHeight = 121;

            const legendRect = createSVGElement("rect", {
                x: legendX,
                y: legendY,
                width: legendWidth,
                height: legendHeight,
                rx: 5,
                fill: "white",
                stroke: "black",
                "stroke-width": 2.7,
                class: "node-animated"
            });
            svg.appendChild(legendRect);

            const legendItems = [
                { color: "#874EFE", text: "Personal Recommendation / Opinion" },
                { color: "#4F7A28", text: "Alternative Option" },
                { color: "#929292", text: "Order not strict / Learn anytime" }
            ];

            legendItems.forEach((item, index) => {
                const itemY = legendY + 28 + (index * 32);
                const circle = createSVGElement("circle", {
                    cx: legendX + 34,
                    cy: itemY,
                    r: 9.5,
                    fill: item.color,
                    class: "node-animated"
                });
                svg.appendChild(circle);

                const text = createSVGElement("text", {
                    x: legendX + 52,
                    y: itemY + 2, // Adjust for vertical alignment
                    "font-size": "14px",
                    fill: "var(--text-primary)",
                    class: "node-animated"
                });
                text.textContent = item.text;
                svg.appendChild(text);
            });


            roadmapContainer.appendChild(svg);

            // Apply animations with staggered delay
            const animatedElements = document.querySelectorAll('.node-animated');
            animatedElements.forEach((el, i) => {
                el.style.animationDelay = `${i * 0.02}s`; // Staggered delay
            });
        });
    </script>
</body>
</html>